# -*- coding: utf-8 -*-
"""Демонстрация_Фаги.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hLOwlnFJ5CzzSKDPT7cB_c7jTnBF2nir
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# --- Параметры симуляции ---
GRID_SIZE = 101  # Размер сетки (нечетный для удобства центрирования)
CENTER = GRID_SIZE // 2
RADIUS = 50      # Радиус чашки Петри
N_FRAMES = 120   # Количество кадров (шагов времени)

# Вероятность роста (деления) бактерии в соседнюю пустую клетку
P_GROWTH = 0.6

# Состояния клеток на сетке
EMPTY = 0
BACTERIA = 1
OUT_OF_BOUNDS = -1 # Область вне чашки

# --- Функция для создания начального состояния ---
def create_initial_grid():
    """Создает начальную сетку с одной бактерией в центре круглой чашки."""
    grid = np.full((GRID_SIZE, GRID_SIZE), EMPTY)

    # Создаем круглую маску для чашки Петри
    y, x = np.ogrid[-CENTER:GRID_SIZE-CENTER, -CENTER:GRID_SIZE-CENTER]
    mask = x*x + y*y > RADIUS*RADIUS
    grid[mask] = OUT_OF_BOUNDS

    # Помещаем одну бактерию в самый центр
    grid[CENTER, CENTER] = BACTERIA

    return grid

# --- Основная функция одного шага симуляции ---
def simulation_step(grid):
    """Выполняет один шаг роста колонии."""
    new_grid = grid.copy()

    # Проходим по каждой клетке в сетке
    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            # Если в клетке есть бактерия, она пытается размножиться
            if grid[r, c] == BACTERIA:
                # Проверяем соседей (сверху, снизу, слева, справа)
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = r + dr, c + dc

                    # Убеждаемся, что соседняя клетка находится внутри сетки
                    if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
                        # Если соседняя клетка пуста, есть шанс вырасти в нее
                        if grid[nr, nc] == EMPTY:
                            if np.random.rand() < P_GROWTH:
                                new_grid[nr, nc] = BACTERIA

    return new_grid

# --- Настройка визуализации ---
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

# Создаем две идентичные начальные сетки
grid1 = create_initial_grid()
grid2 = create_initial_grid()

# Отображаем начальное состояние для первой чашки
im1 = axes[0].imshow(grid1, cmap='Greens', vmin=-1, vmax=1)
axes[0].set_title("Чашка Петри 1")
axes[0].set_xticks([])
axes[0].set_yticks([])

# Отображаем начальное состояние для второй чашки
im2 = axes[1].imshow(grid2, cmap='Greens', vmin=-1, vmax=1)
axes[1].set_title("Чашка Петри 2")
axes[1].set_xticks([])
axes[1].set_yticks([])

plt.close() # Предотвращаем отображение статической картинки перед анимацией

# --- Функция обновления для каждого кадра анимации ---
def update(frame):
    global grid1, grid2
    # Делаем один шаг симуляции для каждой сетки
    grid1 = simulation_step(grid1)
    grid2 = simulation_step(grid2)

    # Обновляем данные на графиках
    im1.set_data(grid1)
    im2.set_data(grid2)

    return [im1, im2]

# --- Создание и отображение анимации ---
# Создаем анимацию, вызывая функцию update для каждого кадра
anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=100, blit=True)

# Отображаем анимацию в ячейке Colab
HTML(anim.to_jshtml())

"""https://www.sciencedirect.com/science/article/pii/S0956713512006214?casa_token=bS3esZcQY3YAAAAA:KaDOksGNI9G7cLpLqmDz64-DbfqC-ixzKQo-QyDPnGDb0a0WGdgdgSYtO7GRTXC3ygbSW8nLDr8

1.  **Лаг-фаза (Lag Phase):** Период адаптации. Рост очень медленный или отсутствует.
2.  **Экспоненциальная фаза (Log Phase):** Быстрый рост, когда ресурсов много, а места достаточно.
3.  **Стационарная фаза (Stationary Phase):** Рост замедляется и прекращается по мере истощения ресурсов и заполнения пространства.

Мы реализуем это с помощью **логистической модели роста**, которая идеально описывает эти фазы. Вероятность деления бактерии будет высокой в начале и будет стремиться к нулю по мере приближения популяции к максимальной емкости "чашки Петри".

### Ключевые изменения в коде:

1.  **Прощаемся с `P_GROWTH`**: Удаляем эту константу.
2.  **Вводим параметры модели**:
    *   `r` (intrinsic growth rate): Максимальная "вероятность" роста в идеальных условиях.
    *   `lag_duration`: Длительность лаг-фазы в кадрах анимации.
3.  **Вычисляем емкость среды (K)**: Максимальное количество бактерий, которое может поместиться в чашке.
4.  **Создаем функцию `calculate_logistic_prob`**: Эта функция будет на каждом шаге вычислять новую вероятность роста на основе текущего числа бактерий (`N`) и максимальной емкости (`K`).
5.  **Моделируем двух разных производителей**: Мы создадим два набора параметров: один для "хорошего" производителя (короткая лаг-фаза, быстрый рост) и один для "плохого" (длинная лаг-фаза, возможно, чуть медленнее рост).
6.  **Добавляем график**: Рядом с чашками Петри мы добавим третий график, который будет в реальном времени строить S-образные кривые роста для обеих популяций. Это наглядно покажет, что симуляция действительно следует математической модели.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# --- Параметры симуляции ---
GRID_SIZE = 101
CENTER = GRID_SIZE // 2
RADIUS = 50
N_FRAMES = 200 # Увеличим время симуляции, чтобы увидеть все фазы

# Состояния клеток
EMPTY = 0
BACTERIA = 1
OUT_OF_BOUNDS = -1

# --- Параметры для двух производителей (МОДЕЛЬ!) ---
# Производитель 1: "Хорошая" культура с высокой устойчивостью
# Короткая фаза адаптации (лаг), высокая скорость роста.
PRODUCER_1_PARAMS = {
    'lag_duration': 15,  # Короткая лаг-фаза в кадрах
    'r': 0.9              # Максимальная вероятность роста (intrinsic growth rate)
}

# Производитель 2: "Проблемная" культура с низкой устойчивостью
# Длинная фаза адаптации, возможно, клетки в стрессе и растут чуть медленнее.
PRODUCER_2_PARAMS = {
    'lag_duration': 60, # Длинная лаг-фаза в кадрах
    'r': 0.8             # Слегка пониженная скорость роста
}


# --- Функции ---

def create_initial_grid():
    """Создает начальную сетку с одной бактерией в центре круглой чашки."""
    grid = np.full((GRID_SIZE, GRID_SIZE), EMPTY, dtype=np.int8)
    y, x = np.ogrid[-CENTER:GRID_SIZE - CENTER, -CENTER:GRID_SIZE - CENTER]
    mask = x * x + y * y > RADIUS * RADIUS
    grid[mask] = OUT_OF_BOUNDS
    grid[CENTER, CENTER] = BACTERIA
    return grid

def calculate_carrying_capacity(grid):
    """Вычисляет максимальную емкость чашки (K)."""
    return np.sum(grid != OUT_OF_BOUNDS)

def calculate_logistic_prob(N, K, r, frame, lag_duration):
    """
    Вычисляет вероятность роста на основе логистической модели.
    N: текущая популяция
    K: максимальная емкость
    r: максимальная скорость роста
    frame: текущий кадр для определения лаг-фазы
    """
    # 1. Лаг-фаза
    if frame < lag_duration:
        return 0.01  # Очень низкая вероятность роста во время адаптации

    # Если популяция достигла максимума, рост прекращается
    if N >= K:
        return 0

    # 2. Экспоненциальная и 3. Стационарная фазы
    # Формула: r * (1 - N/K). Вероятность падает по мере роста N.
    return r * (1 - N / K)

def simulation_step(grid, K, params, frame):
    """Выполняет один шаг симуляции с использованием модели роста."""
    new_grid = grid.copy()

    # Рассчитываем вероятность роста для ТЕКУЩЕГО шага
    current_population = np.sum(grid == BACTERIA)
    p_growth_dynamic = calculate_logistic_prob(
        current_population, K, params['r'], frame, params['lag_duration']
    )

    # Если вероятность слишком низкая, можем пропустить шаг для оптимизации
    if p_growth_dynamic < 0.001:
        return new_grid

    # Находим все бактерии, у которых есть пустые соседи (граница колонии)
    # Это намного эффективнее, чем проверять каждую клетку в сетке
    bacteria_coords = np.argwhere(grid == BACTERIA)

    for r, c in bacteria_coords:
        # Проверяем соседей
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            # Проверяем, что сосед внутри поля и пуст
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                if np.random.rand() < p_growth_dynamic:
                    new_grid[nr, nc] = BACTERIA

    return new_grid

# --- Настройка визуализации ---
fig, axes = plt.subplots(1, 3, figsize=(15, 5), gridspec_kw={'width_ratios': [1, 1, 1.2]})

# Инициализация
grid1 = create_initial_grid()
grid2 = create_initial_grid()
K = calculate_carrying_capacity(grid1) # K одинаково для обеих чашек

# --- Настройка Чашки 1 ---
im1 = axes[0].imshow(grid1, cmap='Greens', vmin=-1, vmax=1, interpolation='none')
axes[0].set_title("Производитель 1 (короткий лаг)")
axes[0].set_xticks([])
axes[0].set_yticks([])

# --- Настройка Чашки 2 ---
im2 = axes[1].imshow(grid2, cmap='Greens', vmin=-1, vmax=1, interpolation='none')
axes[1].set_title(f"Производитель 2 (лаг x{PRODUCER_2_PARAMS['lag_duration']/PRODUCER_1_PARAMS['lag_duration']:.0f})")
axes[1].set_xticks([])
axes[1].set_yticks([])

# --- Настройка графика роста ---
population_history1 = []
population_history2 = []
time_steps = []

ax_plot = axes[2]
line1, = ax_plot.plot([], [], color='g', label='Производитель 1')
line2, = ax_plot.plot([], [], color='darkorange', linestyle='--', label='Производитель 2')
ax_plot.set_title("Кривые роста (N от времени)")
ax_plot.set_xlabel("Время (шаги симуляции)")
ax_plot.set_ylabel("Численность популяции (N)")
ax_plot.set_xlim(0, N_FRAMES)
ax_plot.set_ylim(0, K * 1.1)
ax_plot.axhline(K, color='r', linestyle=':', label='Емкость среды (K)')
ax_plot.legend()
ax_plot.grid(True)

plt.tight_layout()
plt.close() # Предотвращаем отображение статической картинки

# --- Функция обновления анимации ---
def update(frame):
    global grid1, grid2

    # Шаг симуляции для каждой чашки со своими параметрами
    grid1 = simulation_step(grid1, K, PRODUCER_1_PARAMS, frame)
    grid2 = simulation_step(grid2, K, PRODUCER_2_PARAMS, frame)

    # Обновляем изображения
    im1.set_data(grid1)
    im2.set_data(grid2)

    # Собираем данные для графика
    time_steps.append(frame)
    population_history1.append(np.sum(grid1 == BACTERIA))
    population_history2.append(np.sum(grid2 == BACTERIA))

    # Обновляем линии на графике
    line1.set_data(time_steps, population_history1)
    line2.set_data(time_steps, population_history2)

    return [im1, im2, line1, line2]

# --- Создание и отображение анимации ---
anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=100, blit=True)
HTML(anim.to_jshtml())

"""https://www.frontiersin.org/journals/microbiology/articles/10.3389/fmicb.2021.724767/full


https://pmc.ncbi.nlm.nih.gov/articles/PMC10772058/pdf/tcp-31-167.pdf

https://www.mdpi.com/1999-4915/14/11/2483

### Какие концепции из ОДУ были "интегрированы" в код:

1.  **Рост бактерий (логистический):**
    *   **В ОДУ (уравнение 2):** Рост описывается членом `SψC / (K+C)`. Это модель Моно, которая зависит от концентрации нутриентов `C`.
    *   **В моем коде:** Я упростил это до логистической модели `r * (1 - N / K)`. Здесь `K` (carrying capacity) — это аналог лимитирующего ресурса. Этот член отвечает за S-образную кривую роста и стационарную фазу, когда колония заполняет пространство. **Интегрировано как базовый механизм роста.**

2.  **Адсорбция фага и заражение чувствительных клеток:**
    *   **В ОДУ (уравнение 2):** Убыль чувствительных клеток от фага `A` описывается членом `-δA*S*A`.
    *   **В моем коде:** Это правило `if np.random.rand() < P_INFECTION` в `simulation_step`, когда агент `PHAGE` находится рядом с агентом `SUSCEPTIBLE`. Константа `P_INFECTION` — это прямой аналог константы скорости адсорбции `δA`. **Интегрировано как ключевое правило взаимодействия.**

3.  **Лизис зараженных клеток (с задержкой):**
    *   **В ОДУ (уравнение 6):** Гибель зараженных клеток описывается членом с временной задержкой `-IA(t-lA)`. Это Delay Differential Equation (DDE).
    *   **В моем коде:** Это реализовано **идеально и напрямую** через массив `infection_timers` и константу `LATENCY_PERIOD`. Клетка переходит в состояние `INFECTED` и ждет `LATENCY_PERIOD` шагов, прежде чем погибнуть. **Интегрировано как важнейший временной параметр.**

4.  **Высвобождение новых фагов (Burst Size):**
    *   **В ОДУ (уравнение 13):** Рост популяции фагов описывается членом `βA * IA(t-lA)`.
    *   **В моем коде:** Когда таймер зараженной клетки истекает, она погибает и высвобождает `BURST_SIZE` новых агентов `PHAGE` в соседние клетки. Константа `BURST_SIZE` — это прямой аналог `βA`. **Интегрировано как механизм размножения фага.**

5.  **Естественный распад фагов:**
    *   **В ОДУ (уравнение 13):** Убыль фагов описывается членом `-φA*A`.
    *   **В моем коде:** Это правило `if np.random.rand() < P_DECAY` для каждого агента `PHAGE`. `P_DECAY` — это аналог константы распада `φA`. **Интегрировано для реализма.**

6.  **Существование устойчивых клеток:**
    *   **В ОДУ:** Для них есть отдельные уравнения (3, 4, 5) с собственными параметрами.
    *   **В моем коде:** Введено состояние `RESISTANT`, которое **игнорирует правило заражения**. Это прямое отражение сути устойчивости. **Интегрировано как фундаментальное свойство популяции.**

### Какие концепции из ОДУ были упущены и почему:

1.  **Динамика нутриентов (Хемостат):**
    *   **Что упущено:** Уравнение (1) для концентрации ресурса `C` и зависимость роста от `C`. Также упущен "поток" (`ω`), который вымывает клетки и нутриенты из системы.
    *   **Почему:** Моя симуляция моделирует статичную чашку Петри, а не проточный хемостат. Это закрытая система. Зависимость от нутриентов упрощена до общей "емкости среды" `K`, что достаточно для визуализации и сильно упрощает модель, делая ее понятнее.

2.  **"Клетки в убежище" (Refuge Cells / Biofilm):**
    *   **Что упущено:** В статье Nilsson есть сложные уравнения (26, 27) для клеток, которые временно становятся метаболически неактивными и неуязвимыми для фагов.
    *   **Почему:** Это очень продвинутая концепция. Ее добавление сильно усложнило бы код и визуализацию, не добавляя принципиально нового для ответа на исходный вопрос о разнице между производителями. Я сфокусировался на более простом и фундаментальном факторе — соотношении устойчивых/чувствительных клеток.

3.  **Динамическое возникновение мутаций:**
    *   **Что упущено:** Член `(μA + μB)SψC / (K+C)` в уравнении (2), описывающий появление устойчивых мутантов из чувствительных клеток в процессе деления.
    *   **Почему:** Моя симуляция моделирует **результат** этого долгого эволюционного процесса, а не сам процесс. Ваша задача — показать разницу между культурами, которые **уже** сформировались в разных условиях. Поэтому я задаю начальное соотношение `(0.95, 0.05)` как данность, а не симулирую, как оно получилось. Это прямое и эффективное решение поставленной задачи.

4.  **Взаимодействие нескольких типов фагов:**
    *   **Что упущено:** Статья Nilsson и ее программа "Cocktail" созданы для моделирования двух разных фагов (A и B) и их взаимного влияния (например, суперинфекции).
    *   **Почему:** Для демонстрации основного принципа достаточно одного типа фагов. Добавление второго усложнило бы модель без необходимости.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import matplotlib.colors as mcolors

# --- Параметры симуляции ---
GRID_SIZE = 101
CENTER = GRID_SIZE // 2
RADIUS = 50
N_FRAMES = 300 # Увеличим время, чтобы увидеть полную динамику

# --- Новые состояния клеток ---
EMPTY = 0
SUSCEPTIBLE = 1  # Чувствительная бактерия
RESISTANT = 2    # Устойчивая бактерия
PHAGE = 3        # Фаг
INFECTED = 4     # Зараженная клетка
OUT_OF_BOUNDS = -1

# --- Параметры модели "Бактерия-Фаг" ---
# Общие параметры
P_INFECTION = 0.75       # Вероятность заражения при контакте фага с чувств. клеткой
LATENCY_PERIOD = 8       # Кадров от заражения до лизиса (гибели)
BURST_SIZE = 10          # Сколько новых фагов появляется после гибели одной клетки
P_DECAY = 0.05           # Вероятность естественного распада фага за один кадр
PHAGE_ADD_FRAME = 50     # На каком кадре "заразить" чашку фагами
INITIAL_PHAGE_COUNT = 150 # Сколько фагов добавить

# --- Параметры для двух производителей ---
# Производитель 1: "Хорошая" культура (в основном УСТОЙЧИВАЯ)
PRODUCER_1_PARAMS = {
    'initial_ratio': (0.05, 0.95), # (доля чувствительных, доля устойчивых)
    'r_susc': 0.9,                 # Скорость роста чувствительных
    'r_res': 0.85                  # Скорость роста устойчивых (цена за устойчивость)
}

# Производитель 2: "Проблемная" культура (в основном ЧУВСТВИТЕЛЬНАЯ)
PRODUCER_2_PARAMS = {
    'initial_ratio': (0.95, 0.05), # (доля чувствительных, доля устойчивых)
    'r_susc': 0.9,
    'r_res': 0.85
}

# --- Вспомогательные структуры ---
# Таймеры для зараженных клеток
infection_timers = np.zeros((GRID_SIZE, GRID_SIZE), dtype=np.int8)

# --- Функции ---

def create_initial_grid(ratio):
    """Создает сетку с начальной смешанной колонией."""
    grid = np.full((GRID_SIZE, GRID_SIZE), EMPTY, dtype=np.int8)
    y, x = np.ogrid[-CENTER:GRID_SIZE - CENTER, -CENTER:GRID_SIZE - CENTER]
    mask = x * x + y * y > RADIUS * RADIUS
    grid[mask] = OUT_OF_BOUNDS

    # Создаем маленькую начальную колонию в центре
    colony_radius = 2
    y_c, x_c = np.ogrid[-colony_radius:colony_radius+1, -colony_radius:colony_radius+1]
    colony_mask = x_c*x_c + y_c*y_c <= colony_radius*colony_radius

    # Заполняем колонию согласно заданной пропорции
    for r_offset in range(-colony_radius, colony_radius + 1):
        for c_offset in range(-colony_radius, colony_radius + 1):
            if colony_mask[r_offset+colony_radius, c_offset+colony_radius]:
                if np.random.rand() < ratio[0]:
                    grid[CENTER + r_offset, CENTER + c_offset] = SUSCEPTIBLE
                else:
                    grid[CENTER + r_offset, CENTER + c_offset] = RESISTANT
    return grid

def calculate_carrying_capacity(grid):
    return np.sum(grid != OUT_OF_BOUNDS)

def simulation_step(grid, K, params, frame):
    """Выполняет один шаг симуляции с фагами."""
    global infection_timers
    new_grid = grid.copy()

    # 1. Добавление фагов в определенный момент времени
    if frame == PHAGE_ADD_FRAME:
        empty_coords = np.argwhere(grid == EMPTY)
        if len(empty_coords) > INITIAL_PHAGE_COUNT:
            phage_indices = np.random.choice(len(empty_coords), INITIAL_PHAGE_COUNT, replace=False)
            for idx in phage_indices:
                r, c = empty_coords[idx]
                new_grid[r, c] = PHAGE

    # Координаты всех типов клеток для эффективной обработки
    susc_coords = np.argwhere(grid == SUSCEPTIBLE)
    res_coords = np.argwhere(grid == RESISTANT)
    phage_coords = np.argwhere(grid == PHAGE)

    # 2. Рост бактерий (по логистической модели)
    total_bacteria = len(susc_coords) + len(res_coords)
    # Рост чувствительных
    p_growth_s = params['r_susc'] * (1 - total_bacteria / K)
    if p_growth_s > 0:
        for r, c in susc_coords:
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                    if np.random.rand() < p_growth_s: new_grid[nr, nc] = SUSCEPTIBLE
    # Рост устойчивых
    p_growth_r = params['r_res'] * (1 - total_bacteria / K)
    if p_growth_r > 0:
        for r, c in res_coords:
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                    if np.random.rand() < p_growth_r: new_grid[nr, nc] = RESISTANT

    grid = new_grid.copy() # Обновляем сетку, чтобы фаги действовали на выросшие бактерии

    # 3. Действия фагов: заражение и движение
    for r, c in phage_coords:
        # Естественный распад
        if np.random.rand() < P_DECAY:
            new_grid[r,c] = EMPTY
            continue

        infected_neighbor = False
        # Проверка соседей на заражение
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == SUSCEPTIBLE:
                if np.random.rand() < P_INFECTION:
                    new_grid[nr, nc] = INFECTED
                    infection_timers[nr, nc] = LATENCY_PERIOD
                    new_grid[r, c] = EMPTY # Фаг адсорбировался и исчез
                    infected_neighbor = True
                    break
        if infected_neighbor: continue

        # Если никого не заразил, двигается в случайную пустую клетку
        empty_neighbors = []
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                empty_neighbors.append((nr, nc))
        if empty_neighbors:
            nr, nc = empty_neighbors[np.random.randint(len(empty_neighbors))]
            new_grid[nr, nc] = PHAGE
            new_grid[r, c] = EMPTY

    # 4. Обработка зараженных клеток: таймер и лизис
    infected_coords_before_lysis = np.argwhere(grid == INFECTED)
    for r, c in infected_coords_before_lysis:
        infection_timers[r, c] -= 1
        if infection_timers[r, c] <= 0:
            new_grid[r, c] = EMPTY # Клетка погибает
            # Высвобождение новых фагов
            neighbors = []
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1), (-1,-1), (-1,1), (1,-1), (1,1)]:
                 nr, nc = r + dr, c + dc
                 if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and new_grid[nr, nc] == EMPTY:
                     neighbors.append((nr,nc))

            for _ in range(BURST_SIZE):
                if not neighbors: break
                idx = np.random.randint(len(neighbors))
                nr, nc = neighbors.pop(idx)
                new_grid[nr, nc] = PHAGE

    return new_grid

# --- Настройка визуализации ---
fig, axes = plt.subplots(1, 3, figsize=(15, 5), gridspec_kw={'width_ratios': [1, 1, 1.2]})

# Цвета для разных состояний
colors = ['#FFFFFF', '#34A853', '#4285F4', '#EA4335', '#FBBC05', '#70757a']
#          EMPTY,   SUSCEPTIBLE, RESISTANT,  PHAGE,     INFECTED,  OUT_OF_BOUNDS
bounds = [-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5]
cmap = mcolors.ListedColormap(colors)
norm = mcolors.BoundaryNorm(bounds, cmap.N)

# Инициализация
grid1 = create_initial_grid(PRODUCER_1_PARAMS['initial_ratio'])
grid2 = create_initial_grid(PRODUCER_2_PARAMS['initial_ratio'])
K = calculate_carrying_capacity(grid1)

# --- Настройка Чашки 1 ---
im1 = axes[0].imshow(grid1, cmap=cmap, norm=norm, interpolation='none')
axes[0].set_title("Производитель 1 (95% устойчивых)")
axes[0].set_xticks([]); axes[0].set_yticks([])

# --- Настройка Чашки 2 ---
im2 = axes[1].imshow(grid2, cmap=cmap, norm=norm, interpolation='none')
axes[1].set_title("Производитель 2 (5% устойчивых)")
axes[1].set_xticks([]); axes[1].set_yticks([])

# --- Настройка графика роста ---
history = {'t': [], 'b1': [], 'p1': [], 'b2': [], 'p2': []}
ax_plot = axes[2]
line_b1, = ax_plot.plot([], [], color='#006400', label='Бактерии 1')
line_p1, = ax_plot.plot([], [], color='#EA4335', linestyle=':', label='Фаги 1')
line_b2, = ax_plot.plot([], [], color='#90EE90', label='Бактерии 2')
line_p2, = ax_plot.plot([], [], color='#FADADD', linestyle=':', label='Фаги 2')

ax_plot.set_title("Динамика 'Бактерии-Фаги'")
ax_plot.set_xlabel("Время (шаги симуляции)")
ax_plot.set_ylabel("Численность популяции")
ax_plot.set_xlim(0, N_FRAMES)
ax_plot.set_ylim(0, K * 1.1)
ax_plot.axvline(PHAGE_ADD_FRAME, color='grey', linestyle='--', label='Заражение фагами')
ax_plot.legend(fontsize='small')
ax_plot.grid(True)
ax_plot.set_yscale('log') # Логарифмическая шкала для лучшей видимости
ax_plot.set_ylim(1, K * 1.5)

plt.tight_layout()
plt.close()

# --- Функция обновления анимации ---
def update(frame):
    global grid1, grid2

    grid1 = simulation_step(grid1, K, PRODUCER_1_PARAMS, frame)
    grid2 = simulation_step(grid2, K, PRODUCER_2_PARAMS, frame)

    im1.set_data(grid1)
    im2.set_data(grid2)

    history['t'].append(frame)
    history['b1'].append(np.sum((grid1 == SUSCEPTIBLE) | (grid1 == RESISTANT) | (grid1 == INFECTED)))
    history['p1'].append(np.sum(grid1 == PHAGE))
    history['b2'].append(np.sum((grid2 == SUSCEPTIBLE) | (grid2 == RESISTANT) | (grid2 == INFECTED)))
    history['p2'].append(np.sum(grid2 == PHAGE))

    line_b1.set_data(history['t'], history['b1'])
    line_p1.set_data(history['t'], history['p1'])
    line_b2.set_data(history['t'], history['b2'])
    line_p2.set_data(history['t'], history['p2'])

    return [im1, im2, line_b1, line_p1, line_b2, line_p2]

# --- Создание и отображение анимации ---
anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=120, blit=True)
HTML(anim.to_jshtml())

"""**Новая гипотеза:** Генетически штаммы идентичны (и в основном чувствительны к фагам). Но технология производства у **Производителя 1** (например, определенный стресс или состав среды) "приучает" бактерии переходить в метаболически неактивное, "спящее" состояние при опасности. У **Производителя 2** культура всегда активна и готова к росту.

Когда появляются фаги:
*   У **Производителя 1** большая часть популяции "прячется" в убежище, становясь невидимой для фагов. Фаги уничтожают активное меньшинство, но затем им нечем питаться, и они вымирают. После этого "спящие" клетки просыпаются и восстанавливают колонию. **Культура выживает.**
*   У **Производителя 2** почти вся популяция активна и уязвима. Фаги устраивают "пир", их популяция взрывообразно растет, и они уничтожают почти всю культуру. **Культура погибает.**

Давайте внедрим это в код.

### Какие изменения необходимы в коде:

1.  **Новые состояния клеток:** Добавим `SUSCEPTIBLE_REFUGE` и `RESISTANT_REFUGE`. Это будут бактерии в "спящем" состоянии.
2.  **Новые параметры:** Введем две вероятности: `p_enter_refuge` (вероятность "заснуть") и `p_leave_refuge` (вероятность "проснуться"). Именно эти параметры будут отличать двух производителей.
3.  **Новые правила в `simulation_step`:**
    *   **Пробуждение:** На каждом шаге "спящие" клетки имеют шанс проснуться.
    *   **Засыпание:** Активные бактерии (которые не растут и не заражены) имеют шанс "заснуть".
    *   **Неуязвимость:** Фаги смогут атаковать только активные чувствительные клетки. Клетки в убежище для них невидимы.
4.  **Обновленная визуализация:** Новые цвета для "спящих" клеток и обновленные графики, показывающие общую выживаемость.

"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import matplotlib.colors as mcolors

# --- Параметры симуляции ---
GRID_SIZE = 101
CENTER = GRID_SIZE // 2
RADIUS = 50
N_FRAMES = 300

# --- Новые состояния клеток ---
EMPTY = 0
SUSCEPTIBLE = 1         # Активная чувствительная
RESISTANT = 2           # Активная устойчивая
PHAGE = 3               # Фаг
INFECTED = 4            # Зараженная
SUSCEPTIBLE_REFUGE = 5  # "Спящая" чувствительная
RESISTANT_REFUGE = 6    # "Спящая" устойчивая
OUT_OF_BOUNDS = -1

# --- Параметры модели "Бактерия-Фаг" ---
P_INFECTION = 0.75
LATENCY_PERIOD = 8
BURST_SIZE = 10
P_DECAY = 0.05
PHAGE_ADD_FRAME = 50
INITIAL_PHAGE_COUNT = 150

# --- НОВАЯ ГИПОТЕЗА: Разница в склонности к "спячке" ---
# Производитель 1: "Хорошая" культура (ВЫСОКАЯ склонность к уходу в убежище)
PRODUCER_1_PARAMS = {
    'initial_ratio': (0.95, 0.05), # Почти все генетически чувствительны
    'r_susc': 0.9,
    'r_res': 0.85,
    'p_enter_refuge': 0.1,   # 10% шанс "заснуть" на каждом шаге
    'p_leave_refuge': 0.02   # 2% шанс "проснуться"
}

# Производитель 2: "Проблемная" культура (НИЗКАЯ склонность к уходу в убежище)
PRODUCER_2_PARAMS = {
    'initial_ratio': (0.95, 0.05), # Генетически такая же
    'r_susc': 0.9,
    'r_res': 0.85,
    'p_enter_refuge': 0.001, # Почти никогда не "засыпает"
    'p_leave_refuge': 0.02
}

# --- Вспомогательные структуры ---
infection_timers = np.zeros((GRID_SIZE, GRID_SIZE), dtype=np.int8)

# --- Функции ---

def create_initial_grid(ratio):
    grid = np.full((GRID_SIZE, GRID_SIZE), EMPTY, dtype=np.int8)
    y, x = np.ogrid[-CENTER:GRID_SIZE - CENTER, -CENTER:GRID_SIZE - CENTER]
    mask = x * x + y * y > RADIUS * RADIUS
    grid[mask] = OUT_OF_BOUNDS

    colony_radius = 5 # Сделаем начальную колонию побольше
    for r in range(CENTER - colony_radius, CENTER + colony_radius + 1):
        for c in range(CENTER - colony_radius, CENTER + colony_radius + 1):
            if (r-CENTER)**2 + (c-CENTER)**2 <= colony_radius**2:
                if np.random.rand() < ratio[0]:
                    grid[r, c] = SUSCEPTIBLE
                else:
                    grid[r, c] = RESISTANT
    return grid

def calculate_carrying_capacity(grid):
    return np.sum(grid != OUT_OF_BOUNDS)

def simulation_step(grid, K, params, frame):
    global infection_timers
    new_grid = grid.copy()

    # 1. Добавление фагов
    if frame == PHAGE_ADD_FRAME:
        empty_coords = np.argwhere(grid == EMPTY)
        if len(empty_coords) > INITIAL_PHAGE_COUNT:
            phage_indices = np.random.choice(len(empty_coords), INITIAL_PHAGE_COUNT, replace=False)
            for idx in phage_indices:
                r, c = empty_coords[idx]
                new_grid[r, c] = PHAGE

    # Координаты клеток
    susc_coords = np.argwhere(grid == SUSCEPTIBLE)
    res_coords = np.argwhere(grid == RESISTANT)
    susc_ref_coords = np.argwhere(grid == SUSCEPTIBLE_REFUGE)
    res_ref_coords = np.argwhere(grid == RESISTANT_REFUGE)
    phage_coords = np.argwhere(grid == PHAGE)

    # --- НОВЫЕ ПРАВИЛА: УБЕЖИЩЕ ---
    # 2. "Пробуждение" клеток из убежища
    for r, c in susc_ref_coords:
        if np.random.rand() < params['p_leave_refuge']: new_grid[r, c] = SUSCEPTIBLE
    for r, c in res_ref_coords:
        if np.random.rand() < params['p_leave_refuge']: new_grid[r, c] = RESISTANT

    # 3. "Засыпание" активных клеток
    for r, c in susc_coords:
        if np.random.rand() < params['p_enter_refuge']: new_grid[r, c] = SUSCEPTIBLE_REFUGE
    for r, c in res_coords:
        if np.random.rand() < params['p_enter_refuge']: new_grid[r, c] = RESISTANT_REFUGE

    # Обновляем сетку после переходов в/из убежища
    grid = new_grid.copy()

    # 4. Рост ТОЛЬКО активных бактерий
    active_bacteria = np.sum((grid == SUSCEPTIBLE) | (grid == RESISTANT))
    total_bacteria = active_bacteria + len(susc_ref_coords) + len(res_ref_coords)

    # Рост чувствительных
    p_growth_s = params['r_susc'] * (1 - total_bacteria / K)
    if p_growth_s > 0:
        for r, c in np.argwhere(grid == SUSCEPTIBLE): # Пересчитываем, т.к. кто-то мог уснуть
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                    if np.random.rand() < p_growth_s: new_grid[nr, nc] = SUSCEPTIBLE
    # Рост устойчивых
    p_growth_r = params['r_res'] * (1 - total_bacteria / K)
    if p_growth_r > 0:
         for r, c in np.argwhere(grid == RESISTANT):
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                    if np.random.rand() < p_growth_r: new_grid[nr, nc] = RESISTANT

    grid = new_grid.copy()

    # 5. Действия фагов (как и раньше, но теперь они не видят "спящих")
    for r, c in phage_coords:
        if np.random.rand() < P_DECAY: new_grid[r,c] = EMPTY; continue
        infected_neighbor = False
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == SUSCEPTIBLE:
                if np.random.rand() < P_INFECTION:
                    new_grid[nr, nc] = INFECTED; infection_timers[nr, nc] = LATENCY_PERIOD
                    new_grid[r, c] = EMPTY; infected_neighbor = True; break
        if infected_neighbor: continue
        empty_neighbors = []
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                empty_neighbors.append((nr, nc))
        if empty_neighbors:
            nr, nc = empty_neighbors[np.random.randint(len(empty_neighbors))]
            new_grid[nr, nc] = PHAGE; new_grid[r, c] = EMPTY

    # 6. Лизис зараженных клеток (без изменений)
    infected_coords_before_lysis = np.argwhere(grid == INFECTED)
    for r, c in infected_coords_before_lysis:
        infection_timers[r, c] -= 1
        if infection_timers[r, c] <= 0:
            new_grid[r, c] = EMPTY
            neighbors = []
            for dr in range(-1, 2):
                for dc in range(-1, 2):
                    if dr == 0 and dc == 0: continue
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and new_grid[nr, nc] == EMPTY:
                        neighbors.append((nr,nc))
            for _ in range(BURST_SIZE):
                if not neighbors: break
                idx = np.random.randint(len(neighbors))
                nr, nc = neighbors.pop(idx)
                new_grid[nr, nc] = PHAGE
    return new_grid

# --- Настройка визуализации ---
fig, axes = plt.subplots(1, 3, figsize=(15, 5), gridspec_kw={'width_ratios': [1, 1, 1.2]})

# Новые цвета
colors = ['#FFFFFF',  # 0 EMPTY
          '#34A853',  # 1 SUSCEPTIBLE (яркий)
          '#4285F4',  # 2 RESISTANT   (яркий)
          '#EA4335',  # 3 PHAGE
          '#FBBC05',  # 4 INFECTED
          '#a0d6a2',  # 5 SUSCEPTIBLE_REFUGE (тусклый)
          '#a1c2fa',  # 6 RESISTANT_REFUGE   (тусклый)
          '#70757a']  # -1 OUT_OF_BOUNDS
bounds = [-1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5]
cmap = mcolors.ListedColormap(colors)
norm = mcolors.BoundaryNorm(bounds, cmap.N)

# Инициализация
grid1 = create_initial_grid(PRODUCER_1_PARAMS['initial_ratio'])
grid2 = create_initial_grid(PRODUCER_2_PARAMS['initial_ratio'])
K = calculate_carrying_capacity(grid1)

im1 = axes[0].imshow(grid1, cmap=cmap, norm=norm, interpolation='none')
axes[0].set_title("Произв. 1 (Высокая склонность к спячке)")
axes[0].set_xticks([]); axes[0].set_yticks([])

im2 = axes[1].imshow(grid2, cmap=cmap, norm=norm, interpolation='none')
axes[1].set_title("Произв. 2 (Низкая склонность к спячке)")
axes[1].set_xticks([]); axes[1].set_yticks([])

history = {'t': [], 'b1': [], 'p1': [], 'b2': [], 'p2': []}
ax_plot = axes[2]
line_b1, = ax_plot.plot([], [], color='#006400', label='Бактерии 1 (всего)')
line_p1, = ax_plot.plot([], [], color='#EA4335', linestyle=':', label='Фаги 1')
line_b2, = ax_plot.plot([], [], color='#90EE90', label='Бактерии 2 (всего)')
line_p2, = ax_plot.plot([], [], color='#FADADD', linestyle=':', label='Фаги 2')
ax_plot.set_title("Динамика с учетом 'клеток в убежище'")
ax_plot.set_xlabel("Время (шаги симуляции)"); ax_plot.set_ylabel("Численность (log шкала)")
ax_plot.set_xlim(0, N_FRAMES); ax_plot.set_yscale('log'); ax_plot.set_ylim(1, K * 1.5)
ax_plot.axvline(PHAGE_ADD_FRAME, color='grey', linestyle='--', label='Заражение')
ax_plot.legend(fontsize='small'); ax_plot.grid(True)
plt.tight_layout(); plt.close()

def update(frame):
    global grid1, grid2
    grid1 = simulation_step(grid1, K, PRODUCER_1_PARAMS, frame)
    grid2 = simulation_step(grid2, K, PRODUCER_2_PARAMS, frame)
    im1.set_data(grid1); im2.set_data(grid2)

    history['t'].append(frame)
    # Считаем ВСЕ живые бактерии (активные + спящие + зараженные)
    history['b1'].append(np.sum((grid1 > 0) & (grid1 != PHAGE)))
    history['p1'].append(np.sum(grid1 == PHAGE))
    history['b2'].append(np.sum((grid2 > 0) & (grid2 != PHAGE)))
    history['p2'].append(np.sum(grid2 == PHAGE))

    line_b1.set_data(history['t'], history['b1']); line_p1.set_data(history['t'], history['p1'])
    line_b2.set_data(history['t'], history['b2']); line_p2.set_data(history['t'], history['p2'])

    return [im1, im2, line_b1, line_p1, line_b2, line_p2]

anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=120, blit=True)
HTML(anim.to_jshtml())

"""https://www.mdpi.com/1999-4915/17/2/235

### **Часть 1: Как эта статья описывает нашу текущую модель**

Наша последняя модель, где бактерии и фаги последовательно мутируют, чтобы обходить защиту друг друга, — это идеальная визуализация того, что авторы статьи называют **"Arms Race Dynamics" (ARD) или Динамикой Гонки Вооружений**.

*   **Что мы видим в симуляции:** Появляется устойчивая бактерия (новый цвет), затем появляется фаг, который может ее атаковать. Затем появляется "супер-устойчивая" бактерия, и так далее. Это постоянная эскалация.
*   **Что говорит статья:** ARD — это "направленный отбор, благоприятствующий все более устойчивым хозяевам и все более заразным паразитам". Каждый новый мутант строится на основе предыдущего. Статья отмечает, что это часто является **краткосрочным** паттерном эволюции.

Вывод: Наша модель уже демонстрирует один из двух основных типов коэволюции, описанных в научной литературе.

### **Часть 2: Какую новую концепцию предлагает статья для улучшения модели?**

Статья вводит второй, не менее важный тип динамики: **"Fluctuating Selection Dynamics" (FSD) или Динамику Флуктуирующей (Колебательной) Селекции**.

*   **Идея FSD:** Это не линейная гонка, а циклический процесс, похожий на игру "камень-ножницы-бумага". Здесь нет абсолютного "победителя" или "прогресса". Вместо этого отбор благоприятствует редким вариантам.
    *   *Пример:* Если большинство бактерий имеют рецептор "А" (синие), то фаги, атакующие "А", получают огромное преимущество и размножаются.
    *   Это приводит к тому, что бактерии "А" становятся редкими, а бактерии-мутанты с рецептором "Б" (оранжевые), которые раньше были в меньшинстве, теперь в безопасности и становятся доминирующими.
    *   Теперь уже фаги, атакующие "А", теряют "пищу", а преимущество получают редкие фаги-мутанты, атакующие "Б".
    *   Цикл повторяется.

*   **Ключевое отличие от ARD:** В FSD часто существует **"цена адаптации" (fitness cost)**. Например, фаг, мутировавший для атаки на рецептор "Б", может **потерять способность** атаковать рецептор "А". Он становится **специалистом**, а не универсалом. В нашей ARD-модели новый фаг был универсалом, который просто расширял свой арсенал.

### **Часть 3: Какие изменения нужно добавить в модель для симуляции FSD?**

Мы можем легко адаптировать наш код, чтобы он моделировал FSD вместо ARD. Для этого нужно изменить всего два правила, чтобы отразить идею **специализации и "цены адаптации"**.

1.  **Изменение мутации бактерий (для ясности цикла):**
    *   **Было:** Бактерия могла мутировать в любой случайный тип рецептора.
    *   **Станет:** Бактерия будет мутировать только в "следующий" тип рецептора по кругу: `новый_ген_ID = (старый_ген_ID + 1) % N_RECEPTOR_TYPES`. Это создаст предсказуемый цикл (0 -> 1 -> 2 -> ... -> 9 -> 0).

2.  **Изменение мутации фагов (ключевое изменение — специализация):**
    *   **Было:** Фаг мог мутировать в любой случайный тип "ключа".
    *   **Станет:** Фаг, который успешно размножился на бактерии с рецептором "X", при мутации будет пытаться адаптироваться к "следующему" типу бактерий. Его потомки получат "ключ" для атаки на бактерии с рецептором `(X + 1) % N_RECEPTOR_TYPES`. **Он становится узким специалистом, преследующим следующую жертву.**

Вот как можно изменить функцию `simulation_step`, чтобы реализовать эту новую логику. Остальной код остается практически без изменений.

"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import matplotlib.colors as mcolors

# --- Параметры симуляции ---
GRID_SIZE = 101
CENTER = GRID_SIZE // 2
RADIUS = 50
N_FRAMES = 600 # Эволюции нужно время, чтобы показать несколько циклов!

# --- Состояния клеток ---
EMPTY = 0
BACTERIA = 1 # Общее состояние для всех бактерий
PHAGE = 2
INFECTED = 3
OUT_OF_BOUNDS = -1

# --- Параметры ЭВОЛЮЦИИ (FSD) ---
N_RECEPTOR_TYPES = 10      # Количество "генов" в цикле (0 -> 1 -> ... -> 9 -> 0)
P_BACTERIA_MUTATION = 0.01 # 1% шанс, что потомок бактерии мутирует в следующий тип
P_PHAGE_MUTATION = 0.02    # 2% шанс, что потомки фага "переключатся" на следующую цель

# --- Параметры модели "Бактерия-Фаг" ---
P_INFECTION = 0.8
LATENCY_PERIOD = 8
BURST_SIZE = 10
P_DECAY = 0.02
PHAGE_ADD_FRAME = 30
INITIAL_PHAGE_COUNT = 100

# --- Параметры роста ---
r_growth = 0.9

# --- Вспомогательные структуры ---
infection_timers = np.zeros((GRID_SIZE, GRID_SIZE), dtype=np.int8)
genetic_grid = np.zeros((GRID_SIZE, GRID_SIZE), dtype=np.int8)

# --- Функции ---

def create_initial_state():
    """Создает начальное состояние с гомогенной колонией (ген 0)."""
    grid = np.full((GRID_SIZE, GRID_SIZE), EMPTY, dtype=np.int8)
    genetic_grid.fill(0)
    y, x = np.ogrid[-CENTER:GRID_SIZE - CENTER, -CENTER:GRID_SIZE - CENTER]
    mask = x * x + y * y > RADIUS * RADIUS
    grid[mask] = OUT_OF_BOUNDS

    colony_radius = 5
    for r in range(CENTER - colony_radius, CENTER + colony_radius + 1):
        for c in range(CENTER - colony_radius, CENTER + colony_radius + 1):
            if (r-CENTER)**2 + (c-CENTER)**2 <= colony_radius**2:
                grid[r, c] = BACTERIA
                genetic_grid[r, c] = 0 # Все начинают с "гена 0"
    return grid

def calculate_carrying_capacity(grid):
    return np.sum(grid != OUT_OF_BOUNDS)

def simulation_step(grid, K, frame):
    """Выполняет один шаг симуляции с коэволюцией FSD."""
    global infection_timers, genetic_grid
    new_grid = grid.copy()
    new_genetic_grid = genetic_grid.copy()

    # 1. Добавление фагов (с "ключом 0")
    if frame == PHAGE_ADD_FRAME:
        empty_coords = np.argwhere(grid == EMPTY)
        if len(empty_coords) > INITIAL_PHAGE_COUNT:
            phage_indices = np.random.choice(len(empty_coords), INITIAL_PHAGE_COUNT, replace=False)
            for idx in phage_indices:
                r, c = empty_coords[idx]
                new_grid[r, c] = PHAGE
                new_genetic_grid[r, c] = 0 # Фаги начинают с "гена 0"

    # 2. Рост бактерий с ЦИКЛИЧЕСКОЙ мутацией
    bacteria_coords = np.argwhere(grid == BACTERIA)
    total_bacteria = len(bacteria_coords)
    p_growth = r_growth * (1 - total_bacteria / K)
    if p_growth > 0:
        for r, c in bacteria_coords:
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY:
                    if np.random.rand() < p_growth:
                        new_grid[nr, nc] = BACTERIA
                        # ПРАВИЛО МУТАЦИИ FSD ДЛЯ БАКТЕРИЙ
                        if np.random.rand() < P_BACTERIA_MUTATION:
                            # Мутация в следующий тип по кругу
                            new_genetic_grid[nr, nc] = (genetic_grid[r, c] + 1) % N_RECEPTOR_TYPES
                        else:
                            new_genetic_grid[nr, nc] = genetic_grid[r, c]

    grid, genetic_grid = new_grid.copy(), new_genetic_grid.copy()

    # 3. Действия фагов (заражение с проверкой "ключ-замок" и движение)
    for r, c in np.argwhere(grid == PHAGE):
        if np.random.rand() < P_DECAY: new_grid[r,c] = EMPTY; continue
        infected_neighbor = False
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == BACTERIA:
                # Заражение только если гены совпадают
                if genetic_grid[r, c] == genetic_grid[nr, nc] and np.random.rand() < P_INFECTION:
                    new_grid[nr, nc] = INFECTED; infection_timers[nr, nc] = LATENCY_PERIOD
                    new_genetic_grid[nr, nc] = genetic_grid[r, c]
                    new_grid[r, c] = EMPTY; infected_neighbor = True; break
        if infected_neighbor: continue
        # Движение
        empty_neighbors = []
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and grid[nr, nc] == EMPTY: empty_neighbors.append((nr, nc))
        if empty_neighbors:
            nr, nc = empty_neighbors[np.random.randint(len(empty_neighbors))]
            new_grid[nr, nc], new_grid[r, c] = new_grid[r, c], new_grid[nr, nc]
            new_genetic_grid[nr, nc], new_genetic_grid[r, c] = new_genetic_grid[r, c], new_genetic_grid[nr, nc]

    # 4. Лизис с ЦЕЛЕНАПРАВЛЕННОЙ мутацией фага
    for r, c in np.argwhere(grid == INFECTED):
        infection_timers[r, c] -= 1
        if infection_timers[r, c] <= 0:
            new_grid[r, c] = EMPTY
            parent_phage_gen_id = genetic_grid[r, c]
            progeny_gen_id = parent_phage_gen_id

            # ПРАВИЛО МУТАЦИИ FSD ДЛЯ ФАГОВ
            if np.random.rand() < P_PHAGE_MUTATION:
                # Мутант адаптируется к СЛЕДУЮЩЕЙ бактерии в цикле
                progeny_gen_id = (parent_phage_gen_id + 1) % N_RECEPTOR_TYPES

            # Высвобождение
            neighbors = []
            for dr in range(-1, 2):
                for dc in range(-1, 2):
                    if dr == 0 and dc == 0: continue
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE and new_grid[nr, nc] == EMPTY: neighbors.append((nr,nc))
            for _ in range(BURST_SIZE):
                if not neighbors: break
                idx = np.random.randint(len(neighbors))
                nr, nc = neighbors.pop(idx)
                new_grid[nr, nc] = PHAGE
                new_genetic_grid[nr, nc] = progeny_gen_id

    return new_grid, new_genetic_grid

# --- Настройка визуализации ---
fig, (ax_im, ax_plot) = plt.subplots(1, 2, figsize=(12, 6), gridspec_kw={'width_ratios': [1, 1]})

palette = plt.cm.get_cmap('rainbow', N_RECEPTOR_TYPES)
image_data = np.zeros((GRID_SIZE, GRID_SIZE, 4)) # RGBA
im = ax_im.imshow(image_data, interpolation='none')
ax_im.set_title("Динамика Флуктуирующей Селекции (FSD)")
ax_im.set_xticks([]); ax_im.set_yticks([])

history = {'t': [], 'b': [], 'p': []}
line_b, = ax_plot.plot([], [], color='blue', label='Бактерии (всего)')
line_p, = ax_plot.plot([], [], color='red', label='Фаги (всего)')
ax_plot.set_title("Циклы 'Хищник-Жертва'"); ax_plot.set_xlabel("Время"); ax_plot.set_ylabel("Численность (log)")
ax_plot.set_xlim(0, N_FRAMES); ax_plot.set_yscale('log'); ax_plot.set_ylim(1, K * 1.5)
ax_plot.axvline(PHAGE_ADD_FRAME, color='grey', linestyle='--', label='Заражение')
ax_plot.legend(); ax_plot.grid(True)

def update_colors():
    """Обновляет RGBA-массив для отображения с прозрачностью."""
    image_data.fill(0)
    # Задаем черный фон с полной непрозрачностью
    image_data[:, :, 3] = 1.0

    # Проходим по всем клеткам, чтобы установить цвета
    bacteria_mask = grid == BACTERIA
    phage_mask = grid == PHAGE
    infected_mask = grid == INFECTED

    # Бактерии окрашиваются в соответствии с их генетическим ID
    image_data[bacteria_mask] = palette(genetic_grid[bacteria_mask])
    # Фаги - красные
    image_data[phage_mask] = [1, 0, 0, 1]
    # Зараженные - желтые
    image_data[infected_mask] = [1, 1, 0, 1]

    return image_data

def update(frame):
    global grid, genetic_grid
    grid, genetic_grid = simulation_step(grid, K, frame)

    im.set_data(update_colors())

    history['t'].append(frame)
    total_bacteria = np.sum((grid == BACTERIA) | (grid == INFECTED))
    total_phages = np.sum(grid == PHAGE)
    history['b'].append(total_bacteria if total_bacteria > 0 else 1) # чтобы избежать log(0)
    history['p'].append(total_phages if total_phages > 0 else 1)

    line_b.set_data(history['t'], history['b'])
    line_p.set_data(history['t'], history['p'])

    return [im, line_b, line_p]

plt.tight_layout(); plt.close()

# Инициализация
grid = create_initial_state()
K = calculate_carrying_capacity(grid)

anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=80, blit=True)
HTML(anim.to_jshtml())

"""https://www.pnas.org/doi/pdf/10.1073/pnas.2414229121

https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1010746


### **Статья 1: Kimchi et al. (PNAS) — "Bacterial defense and phage counterdefense..."**

Эта статья вводит невероятно элегантную и мощную концепцию, которая идеально ложится на вашу задачу.

**Основная идея:** Эволюция — это не просто смена одного типа рецептора на другой. Бактерии несут в себе целый **"репертуар" из нескольких систем защиты**, а фаги — **"репертуар" систем контрзащиты**. За каждый элемент в репертуаре приходится платить "ценой" в виде снижения приспособленности (бактерии медленнее растут, у фагов меньше потомство).

Система приходит в равновесие не тогда, когда у бактерий максимальное число защит, а когда у них **оптимальное** число защит — достаточное, чтобы выживать, но не слишком большое, чтобы не проигрывать в скорости роста.

**Как это применимо к вашей задаche? (Новая, очень сильная гипотеза)**

*   **Производитель 1 (высокая устойчивость):** Его производственный процесс (возможно, с небольшим, но постоянным давлением фагов) поддерживает культуру в состоянии **оптимального репертуара защиты**. Например, каждая бактерия несет в себе 2-3 разные системы защиты (из 10 возможных). Это делает их устойчивыми к широкому спектру фагов, хотя они и растут не с максимально возможной скоростью.
*   **Производитель 2 (низкая устойчивость):** Его "стерильный" процесс отбирает бактерии по единственному критерию — **максимальная скорость роста**. В таких условиях эволюционно выгодно **сбросить все дорогостоящие системы защиты**. Его культура состоит из "голых" бактерий с 0 или 1 системой защиты. Они — чемпионы по росту в лаборатории, но абсолютно беззащитны перед любым фагом.

**Какие изменения нужно добавить в модель:**

1.  **Изменить "генетический код":**
    *   Вместо одного `genetic_id` у каждой бактерии и фага будет **множество (set) ID их систем защиты/контрзащиты**.
    *   `bacterium.defenses = {2, 5}` (у этой бактерии есть системы защиты №2 и №5)
    *   `phage.counters = {1, 2, 5}` (этот фаг может обойти системы №1, №2 и №5)

2.  **Изменить правило заражения:**
    *   **Было:** `phage.id == bacterium.id`
    *   **Станет:** Фаг заражает бактерию, только если его множество контрзащит **является надмножеством** защит бактерии.
        *   `if phage.counters.issuperset(bacterium.defenses): # Заражение!`
        *   (Пример: Фаг с `{1, 2, 5}` может заразить бактерию с `{2, 5}`, но не может заразить бактерию с `{2, 6}`).

3.  **Внедрить "цену приспособленности":**
    *   Скорость роста бактерии `r` должна зависеть от размера ее репертуара: `r = r_max - cost_per_defense * len(bacterium.defenses)`.
    *   Размер потомства фага `BURST_SIZE` должен зависеть от его репертуара: `burst_size = burst_max - cost_per_counter * len(phage.counters)`.

4.  **Изменить мутации:**
    *   Мутация теперь — это не смена ID, а **случайное добавление или удаление одного ID** из множества защит/контрзащит.

---

### **Статья 2: Leclerc et al. (PLOS) — "Modelling the synergistic effect of bacteriophage and antibiotics..."**

Эта статья вводит совершенно новый, третий фактор в нашу экосистему — **антибиотики**. Это позволяет исследовать синергию и антагонизм, что может быть крайне актуально, если йогурт производится в нестерильных условиях или потребляется человеком, проходящим лечение.

**Основная идея:** Антибиотики и фаги могут действовать синергично (усиливать друг друга) или антагонистично, и результат **критически зависит от времени и дозы**.
*   **Синергия:** Фаги ослабляют популяцию, делая ее более уязвимой к антибиотикам (и наоборот).
*   **Антагонизм:** Антибиотики подавляют рост бактерий настолько, что фагам **не на ком размножаться**. В итоге фаги быстро вымирают, а выжившие после антибиотиков бактерии восстанавливают популяцию.
*   **Главная опасность (Трансдукция):** При одновременном воздействии фаги могут случайно "захватывать" гены устойчивости к антибиотикам у одних бактерий и переносить их другим, **создавая супер-резистентные штаммы**.

**Как это применимо к вашей задаче? (Гипотеза о среде)**

Возможно, проблема не в самой закваске, а в среде, куда она попадает.
*   **Производитель 1 (высокая устойчивость):** Его культура, благодаря своим свойствам (например, склонности к "спячке"), избегает "опасного окна", когда и фаги, и антибиотики действуют одновременно. Она пережидает атаку антибиотиков в неактивном состоянии.
*   **Производитель 2 (низкая устойчивость):** Его всегда активная культура, попадая в среду с фагами и остаточными концентрациями антибиотиков (например, на производстве), становится идеальным "реактором" для создания и отбора мультирезистентных бактерий, что ведет к коллапсу.

**Какие изменения нужно добавить в модель:**

1.  **Добавить слой антибиотиков:**
    *   Создать еще одну сетку, `antibiotic_grid`, хранящую концентрацию антибиотика в каждой ячейке.
    *   Антибиотик должен "распыляться" в определенный момент и медленно диффундировать (усредняться с соседями) и распадаться (`decay`).

2.  **Добавить устойчивость к антибиотикам:**
    *   В "генетический код" бактерий добавить флаги устойчивости, например, `bacterium.is_resistant_to_A = True`.

3.  **Изменить правило выживания бактерий:**
    *   На каждом шаге активная (не "спящая") бактерия, не имеющая устойчивости, имеет вероятность погибнуть, зависящую от концентрации антибиотика в ее ячейке (`kill_prob = antibiotic_grid[r, c] / MIC_concentration`).

4.  **Внедрить Трансдукцию (самая сложная часть):**
    *   Создать новый тип агента: `TRANSDUCING_PHAGE`.
    *   При лизисе бактерии, устойчивой к антибиотику, есть крошечная вероятность (`transduction_probability`), что часть потомства фагов станут `TRANSDUCING_PHAGE`, которые "помнят" ген устойчивости.
    *   Когда такой фаг "заражает" новую чувствительную бактерию, он не убивает ее, а просто **передает ей ген устойчивости**, превращая ее в резистентную.

"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import matplotlib.colors as mcolors
import random

# !!! --- ВАЖНОЕ ИЗМЕНЕНИЕ --- !!!
# Увеличиваем лимит на размер встраиваемой анимации до 50 МБ
plt.rcParams['animation.embed_limit'] = 50

# --- Глобальные параметры ---
GRID_SIZE = 101
CENTER = GRID_SIZE // 2
RADIUS = 50
N_FRAMES = 400

# --- Состояния (типы объектов) ---
EMPTY = 0
BACTERIA = 1
PHAGE = 2
OUT_OF_BOUNDS = -1

# --- Параметры ЭВОЛЮЦИИ и РЕПЕРТУАРОВ ---
N_DEFENSE_TYPES = 10
P_MUTATION = 0.01
COST_PER_DEFENSE = 0.04
COST_PER_COUNTER = 0.8

# --- Параметры ФАГОВ и АНТИБИОТИКОВ ---
P_INFECTION = 0.9
LATENCY_PERIOD = 8
BURST_SIZE_MAX = 12
P_DECAY_PHAGE = 0.03
P_TRANSDUCTION_CREATION = 0.005
ANTIBIOTIC_MIC = 0.5
ANTIBIOTIC_DECAY = 0.01

# --- Параметры Сценария ---
FRAME_ADD_PHAGE = 60
FRAME_ADD_ANTIBIOTIC = 100
INITIAL_PHAGE_COUNT = 150
INITIAL_ANTIBIOTIC_DOSE = 1.0

# --- Классы для агентов ---
class Bacterium:
    def __init__(self, defenses, is_resistant_to_ab):
        self.defenses = defenses
        self.is_resistant_to_ab = is_resistant_to_ab
        self.infected_by = None
        self.infection_timer = 0
        self.type = BACTERIA

class Phage:
    def __init__(self, counters, carries_resistance_gene):
        self.counters = counters
        self.carries_resistance_gene = carries_resistance_gene
        self.type = PHAGE

# --- Функции ---
def create_initial_state(producer_type):
    grid = np.full((GRID_SIZE, GRID_SIZE), None, dtype=object)
    ab_grid = np.zeros((GRID_SIZE, GRID_SIZE), dtype=np.float32)

    y, x = np.ogrid[-CENTER:GRID_SIZE - CENTER, -CENTER:GRID_SIZE - CENTER]
    mask = x * x + y * y > RADIUS * RADIUS

    colony_radius = 5
    for r in range(CENTER - colony_radius, CENTER + colony_radius + 1):
        for c in range(CENTER - colony_radius, CENTER + colony_radius + 1):
            if (r - CENTER)**2 + (c - CENTER)**2 <= colony_radius**2:
                defenses = set()
                if producer_type == 'producer1':
                    defenses = set(random.sample(range(N_DEFENSE_TYPES), 3))

                is_resistant = (r == CENTER and c == CENTER)
                grid[r, c] = Bacterium(defenses, is_resistant_to_ab=is_resistant)

    grid[mask] = OUT_OF_BOUNDS
    return grid, ab_grid

def get_neighbors(r, c, diagonal=False):
    deltas = [(-1,0), (1,0), (0,-1), (0,1)]
    if diagonal:
        deltas.extend([(-1,-1), (-1,1), (1,-1), (1,1)])
    neighbors = []
    for dr, dc in deltas:
        nr, nc = r + dr, c + dc
        if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:
            neighbors.append((nr, nc))
    return neighbors

def mutate_repertoire(repertoire, n_types):
    new_repertoire = repertoire.copy()
    if random.random() < P_MUTATION:
        if random.random() < 0.5 and len(new_repertoire) > 0:
            new_repertoire.remove(random.choice(list(new_repertoire)))
        elif len(new_repertoire) < n_types:
            possible = list(set(range(n_types)) - new_repertoire)
            if possible: new_repertoire.add(random.choice(possible))
    return new_repertoire

def simulation_step(grid, ab_grid, frame):
    new_grid = grid.copy()

    if frame == FRAME_ADD_PHAGE:
        empty_coords = np.argwhere(grid == None)
        if len(empty_coords) > INITIAL_PHAGE_COUNT:
            indices = np.random.choice(len(empty_coords), INITIAL_PHAGE_COUNT, replace=False)
            for idx in indices:
                r, c = empty_coords[idx]
                counters = set(random.sample(range(N_DEFENSE_TYPES), 3))
                new_grid[r, c] = Phage(counters, False)

    if frame == FRAME_ADD_ANTIBIOTIC:
        ab_grid[grid != OUT_OF_BOUNDS] = INITIAL_ANTIBIOTIC_DOSE

    next_ab_grid = ab_grid * (1.0 - ANTIBIOTIC_DECAY)

    coords = [(r, c) for r in range(GRID_SIZE) for c in range(GRID_SIZE)]
    random.shuffle(coords)

    for r, c in coords:
        agent = grid[r, c]
        if agent is None or agent == OUT_OF_BOUNDS: continue

        if agent.type == BACTERIA:
            if not agent.is_resistant_to_ab:
                kill_prob = ab_grid[r, c] / (ab_grid[r, c] + ANTIBIOTIC_MIC)
                if random.random() < kill_prob:
                    new_grid[r, c] = None
                    continue

            if agent.infected_by:
                agent.infection_timer -= 1
                if agent.infection_timer <= 0:
                    phage_parent = agent.infected_by
                    burst_size = int(BURST_SIZE_MAX - COST_PER_COUNTER * len(phage_parent.counters))
                    is_transducing = random.random() < P_TRANSDUCTION_CREATION and agent.is_resistant_to_ab

                    new_grid[r, c] = None

                    empty_neighbors = [pos for pos in get_neighbors(r,c,True) if new_grid[pos] is None]
                    random.shuffle(empty_neighbors)
                    for _ in range(burst_size):
                        if not empty_neighbors: break
                        nr, nc = empty_neighbors.pop()
                        new_counters = mutate_repertoire(phage_parent.counters, N_DEFENSE_TYPES)
                        new_grid[nr, nc] = Phage(new_counters, is_transducing)
                continue

            growth_rate = 0.8 - COST_PER_DEFENSE * len(agent.defenses)
            if random.random() < growth_rate:
                empty_neighbors = [pos for pos in get_neighbors(r,c) if grid[pos] is None]
                if empty_neighbors:
                    nr, nc = random.choice(empty_neighbors)
                    new_defenses = mutate_repertoire(agent.defenses, N_DEFENSE_TYPES)
                    new_grid[nr, nc] = Bacterium(new_defenses, agent.is_resistant_to_ab)

        elif agent.type == PHAGE:
            if random.random() < P_DECAY_PHAGE: new_grid[r, c] = None; continue

            target, target_pos = None, None
            neighbors = get_neighbors(r, c)
            random.shuffle(neighbors)
            for nr, nc in neighbors:
                neighbor = grid[nr, nc]
                if isinstance(neighbor, Bacterium) and not neighbor.infected_by and agent.counters.issuperset(neighbor.defenses) and random.random() < P_INFECTION:
                    target, target_pos = neighbor, (nr, nc)
                    break

            if target:
                if agent.carries_resistance_gene and not target.is_resistant_to_ab:
                    target.is_resistant_to_ab = True
                else:
                    target.infected_by = agent
                    target.infection_timer = LATENCY_PERIOD
                new_grid[r, c] = None
            else:
                empty_neighbors = [pos for pos in get_neighbors(r,c) if grid[pos] is None]
                if empty_neighbors:
                    nr, nc = random.choice(empty_neighbors)
                    new_grid[nr, nc], new_grid[r, c] = new_grid[r, c], None

    return new_grid, next_ab_grid

# --- Настройка Визуализации ---
fig, axes = plt.subplots(1, 3, figsize=(15, 5), gridspec_kw={'width_ratios': [1, 1, 1.2]})

# Создаем RGBA-массивы для прямого контроля над цветом
im_data1 = np.zeros((GRID_SIZE, GRID_SIZE, 4), dtype=np.float32)
im_data2 = np.zeros((GRID_SIZE, GRID_SIZE, 4), dtype=np.float32)

grid1, ab_grid1 = create_initial_state('producer1')
grid2, ab_grid2 = create_initial_state('producer2')
K = np.sum(grid1 != OUT_OF_BOUNDS)

im1 = axes[0].imshow(im_data1, interpolation='none')
axes[0].set_title("Произв. 1 (с репертуаром)")
axes[0].set_xticks([]); axes[0].set_yticks([])

im2 = axes[1].imshow(im_data2, interpolation='none')
axes[1].set_title("Произв. 2 (без репертуара)")
axes[1].set_xticks([]); axes[1].set_yticks([])

history = {'t': [], 'b1': [], 'br1': [], 'p1': [], 'b2': [], 'br2': [], 'p2': []}
ax_plot = axes[2]
line_b1, = ax_plot.plot([], [], color='#4285F4', label='Бактерии 1 (всего)')
line_br1, = ax_plot.plot([], [], color='#0D47A1', linestyle='--', label='AB-R Бактерии 1')
line_p1, = ax_plot.plot([], [], color='red', linestyle=':', label='Фаги 1')
line_b2, = ax_plot.plot([], [], color='#34A853', label='Бактерии 2 (всего)')
ax_plot.set_title("Комплексная динамика"); ax_plot.set_xlabel("Время"); ax_plot.set_ylabel("Численность (log)")
ax_plot.set_xlim(0, N_FRAMES); ax_plot.set_yscale('log'); ax_plot.set_ylim(1, K * 1.5)
ax_plot.axvline(FRAME_ADD_PHAGE, color='grey', linestyle='--', lw=1)
ax_plot.axvline(FRAME_ADD_ANTIBIOTIC, color='grey', linestyle='--', lw=1)
ax_plot.text(FRAME_ADD_PHAGE, 1.5, 'Фаги', rotation=90, verticalalignment='bottom', fontsize='small', color='white')
ax_plot.text(FRAME_ADD_ANTIBIOTIC, 1.5, 'Антибиотик', rotation=90, verticalalignment='bottom', fontsize='small', color='white')

ax2 = ax_plot.twinx()
line_br2, = ax2.plot([], [], color='#1B5E20', linestyle='--', label='AB-R Бактерии 2')
line_p2, = ax2.plot([], [], color='#FFCDD2', linestyle=':', label='Фаги 2')
ax2.set_yscale('log'); ax2.set_ylim(1, K * 1.5); ax2.set_ylabel(""); ax2.tick_params(axis='y', labelright=False)

lines, labels = ax_plot.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax_plot.legend(lines + lines2, labels + labels2, loc='lower center', fontsize='small', ncol=2)

# --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ВИЗУАЛИЗАЦИИ ---
def update_im_data(grid, im_data):
    """Напрямую заполняет RGBA-массив цветов."""
    colors = {
        'out_of_bounds': [0.2, 0.2, 0.2, 1.0],
        'empty':         [0.06, 0.06, 0.06, 1.0],
        'bact':          [0.258, 0.52, 0.956, 1.0], # Синий
        'bact_res':      [0.05, 0.278, 0.6, 1.0],   # Темно-синий
        'phage':         [0.917, 0.26, 0.207, 1.0], # Красный
        'phage_trans':   [0.956, 0.21, 0.627, 1.0], # Розовый
        'infected':      [0.984, 0.737, 0.02, 1.0], # Желтый
        'infected_res':  [0.976, 0.658, 0.1, 1.0]   # Темно-желтый
    }

    im_data[:,:] = colors['empty'] # Фон по умолчанию

    for r in range(GRID_SIZE):
        for c in range(GRID_SIZE):
            agent = grid[r, c]
            if agent == OUT_OF_BOUNDS:
                im_data[r, c] = colors['out_of_bounds']
            elif isinstance(agent, Bacterium):
                if agent.infected_by:
                    im_data[r, c] = colors['infected_res'] if agent.is_resistant_to_ab else colors['infected']
                else:
                    im_data[r, c] = colors['bact_res'] if agent.is_resistant_to_ab else colors['bact']
            elif isinstance(agent, Phage):
                im_data[r, c] = colors['phage_trans'] if agent.carries_resistance_gene else colors['phage']

def update(frame):
    global grid1, ab_grid1, grid2, ab_grid2

    grid1, ab_grid1 = simulation_step(grid1, ab_grid1, frame)
    grid2, ab_grid2 = simulation_step(grid2, ab_grid2, frame)

    update_im_data(grid1, im_data1)
    update_im_data(grid2, im_data2)
    im1.set_data(im_data1)
    im2.set_data(im_data2)

    history['t'].append(frame)

    for grid, prefix in [(grid1, '1'), (grid2, '2')]:
        b, br, p = 0, 0, 0
        for agent in grid.ravel():
            if isinstance(agent, Bacterium):
                b += 1
                if agent.is_resistant_to_ab: br += 1
            elif isinstance(agent, Phage): p += 1
        history['b' + prefix].append(b if b > 0 else 1)
        history['br' + prefix].append(br if br > 0 else 1)
        history['p' + prefix].append(p if p > 0 else 1)

    line_b1.set_data(history['t'], history['b1'])
    line_br1.set_data(history['t'], history['br1'])
    line_p1.set_data(history['t'], history['p1'])
    line_b2.set_data(history['t'], history['b2'])
    line_br2.set_data(history['t'], history['br2'])
    line_p2.set_data(history['t'], history['p2'])

    if frame % 20 == 0:
        print(f"Кадр {frame}/{N_FRAMES}")

    return [im1, im2, line_b1, line_br1, line_p1, line_b2, line_br2, line_p2]

plt.tight_layout()
plt.close()

anim = FuncAnimation(fig, update, frames=N_FRAMES, interval=120, blit=False)
HTML(anim.to_jshtml())

"""# Основная часть

### 1. Какие эволюционные и генетические факторы влияют на фаговую устойчивость?

В нашей модели устойчивость — это абстрактный "репертуар защит". В реальности за этими цифрами стоят конкретные, невероятно разнообразные генетические механизмы. Вот основные из них, сгруппированные по принципу действия:

#### **А. Блокировка "входной двери" (Предотвращение адсорбции)**

Это самый распространенный и интуитивно понятный способ. Если фаг не может прикрепиться, он не может заразить.
*   **Мутация или потеря рецепторов:** Бактерии изменяют или полностью удаляют белки, полисахариды или пили на своей поверхности, которые фаг использует для прикрепления.
    *   **Цена устойчивости:** Часто эти рецепторы выполняют важные функции (например, транспорт питательных веществ). Их потеря может замедлить рост бактерии, что мы и моделируем параметром `COST_PER_DEFENSE`.
*   **Маскировка рецепторов:** Бактерия начинает производить слизистую капсулу (экзополисахариды), которая физически скрывает рецепторы, создавая "щит".

#### **Б. Внутренняя "иммунная система" (Уничтожение ДНК фага)**

Если фаг все же впрыснул свою ДНК, у бактерии есть несколько линий обороны для ее уничтожения.
*   **Системы Рестрикции-Модификации (R-M):** Это "врожденный иммунитет" бактерий. У бактерии есть ферменты (рестриктазы), которые разрезают ДНК в определенных местах. Своя собственная ДНК защищена от разрезания специальными "метками" (модификация, метилирование). ДНК фага таких меток не имеет и немедленно уничтожается.
*   **CRISPR-Cas системы:** Это "адаптивный иммунитет". Бактерия, выжившая после атаки, может "запомнить" фага, встроив фрагмент его ДНК (спейсер) в специальный участок своего генома (CRISPR-массив). В будущем, если фаг с такой же ДНК снова попытается заразить клетку, система Cas, используя РНК-копию спейсера как "ориентировку", находит и разрезает вражескую ДНК.

#### **В. "Альтруистический суицид" (Системы абортивной инфекции - Abi)**

Это стратегия защиты на уровне популяции.
*   Как только клетка понимает, что заражена, она активирует систему, которая вызывает собственную гибель (или уходит в глубокий метаболический стаз) **до того, как фаг успеет размножиться**. Клетка жертвует собой, чтобы спасти своих "сестер" от новой волны фагов. Часто в этом участвуют **токсин-антитоксиновые (ТА) системы**.

**Как это относится к нашей модели:** Наш абстрактный `repertoire = {2, 5, 8}` — это как раз симуляция того, что у бактерии есть, например, мутировавший рецептор (система №2), CRISPR-система против одной семьи фагов (№5) и R-M система (№8).

---

### 2. Какие факторы влияют на конвертацию в профагов (лизогению)?

В нашей модели все фаги — **литические**, то есть они всегда убивают клетку. Но многие фаги являются **умеренными** и могут выбирать: убить клетку сейчас (литический цикл) или встроить свою ДНК в геном бактерии и "заснуть" (лизогенический цикл), став **профагом**. Решение "убить или уснуть" — одно из самых изученных в вирусологии.

Основные факторы, влияющие на этот выбор:

*   **Состояние клетки-хозяина ("Здоровье" жертвы):** Это главный фактор. Если бактерия здорова, активно делится и вокруг много питательных веществ, она является отличной "фабрикой" для новых фагов. В этом случае выгоднее выбрать **литический путь**. Если же бактерия находится в стрессе (голодает, повреждена ДНК), она — плохая фабрика. Фагу выгоднее "переждать плохие времена", интегрировавшись в геном, — **лизогенический путь**.
*   **Множественность инфекции (MOI):** Если одну бактериальную клетку заражает сразу много фагов, это сигнал о том, что фагов в среде очень много, а доступных бактерий — мало. Убивать последнюю "курицу, несущую золотые яйца" невыгодно. В этой ситуации фаги также склоняются к **лизогении**, чтобы сохранить хозяина. Некоторые фаги даже имеют системы коммуникации (похожие на "чувство кворума"), чтобы "посчитать" друг друга и принять коллективное решение.

**Как это относится к нашей модели:** Мы **не учитываем** лизогению. Это одно из наших главных упрощений. Добавление умеренных фагов сделало бы модель еще на порядок сложнее, так как профаги могут давать бактериям новые свойства (например, устойчивость к другим фагам) и "просыпаться" при стрессе.

---

### 3. Какие физические условия мы не учитываем, и есть ли модели для них?

Да, мы упускаем множество важных физических факторов, которые в реальности могут быть решающими.

*   **Пространственная структура и Биопленки:**
    *   **Что упускаем:** В реальности бактерии, особенно в йогурте, могут образовывать не просто колонии, а **биопленки** — сложные структуры, скрепленные матриксом из полисахаридов. Этот матрикс — физический барьер, который мешает фагам добраться до клеток внутри. Фаги могут эффективно уничтожать только поверхностный слой биопленки.
    *   **Модели:** Да, существуют! Это огромное поле. Ищутся по запросам `agent-based model phage biofilm` или `reaction-diffusion model phage biofilm`. Они часто моделируют матрикс как отдельную субстанцию, замедляющую диффузию фагов.

*   **Химические условия среды (pH, ионы):**
    *   **Что упускаем:** Фаги — это белковые капсиды. Их стабильность **сильно зависит от pH (кислотности) и температуры**. Йогурт — это кислая среда (pH ~4.5). Многие фаги при таком pH быстро денатурируют и теряют активность. Кроме того, для адсорбции многим фагам **требуются специфические ионы**, например, Ca²⁺ или Mg²⁺. Если их нет в среде, заражение не произойдет.
    *   **Модели:** Есть. Обычно это не сложные пространственные модели, а ОДУ (как в статьях), где **параметр распада фага (`P_DECAY` в нашем коде) делается функцией от pH и температуры**. Например: `decay_rate = base_decay + k_pH * abs(pH - optimal_pH)`. Ищутся по `phage stability pH model`.

*   **Вязкость среды и Диффузия:**
    *   **Что упускаем:** Наша модель предполагает, что фаги могут свободно перемещаться в соседнюю клетку. Йогурт — вязкая среда. Это сильно **замедляет диффузию** фагов. Фагу требуется гораздо больше времени, чтобы найти новую жертву.
    *   **Модели:** Это моделируется в **реакционно-диффузионных моделях**. Вместо случайных "прыжков" агентов, они используют уравнения диффузии для описания изменения концентрации фагов и бактерий в пространстве.

**Итог:** Наша модель — это мощная, но идеализированная система. Она прекрасно показывает, как работают генетические и эволюционные "правила игры". Однако в реальности на исход битвы огромное влияние оказывают физико-химические "условия на поле боя" — структура биопленки, кислотность среды и ее вязкость.
"""



import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from functools import partial

class PhageResistanceModel:
    """
    Модель динамики бактериофаг-бактериальных взаимодействий
    для исследования факторов устойчивости заквасочных культур
    """

    def __init__(self):
        # Параметры модели (биологически правдоподобные значения)
        self.params = {
            # Рост бактерий
            'mu_max_s': 0.8,    # Макс. скорость роста чувствительных (1/час)
            'mu_max_r': 0.7,    # Макс. скорость роста устойчивых (1/час) - цена устойчивости
            'K_N': 0.1,         # Константа полунасыщения Моно (г/л)
            'Y': 0.5,           # Выход биомассы (г/г субстрата)

            # Взаимодействие с фагами
            'delta': 1.0,       # Константа адсорбции фага (л/час·частица)
            'beta': 50,         # Burst size (частиц/клетку)
            'lambda_lysis': 0.5, # Скорость лизиса (1/час) ~ латентный период 2 часа
            'd_p': 0.1,         # Скорость распада фагов (1/час)

            # Мутации и переходы между состояниями
            'm': 1e-6,          # Частота мутаций S->R при делении
            'alpha_in': 0.05,   # Скорость перехода в спящее состояние (1/час)
            'alpha_out': 0.01,  # Скорость пробуждения из спящего состояния (1/час)

            # Дополнительные параметры среды
            'N0': 10.0,         # Начальная концентрация нутриентов (г/л)
        }

    def equations(self, t, y, params, phage_addition_time=5, phage_dose=1e6):
        """
        Система ОДУ модели
        y = [S, R, I, D, P, N] - вектор состояния
        """
        S, R, I, D, P, N = y

        # Внешнее воздействие - добавление фагов в определенный момент
        if abs(t - phage_addition_time) < 0.1:
            P += phage_dose

        # Параметры
        p = params

        # Функция роста (Моно)
        def mu(mu_max, N):
            return mu_max * N / (p['K_N'] + N)

        mu_s = mu(p['mu_max_s'], N)
        mu_r = mu(p['mu_max_r'], N)

        # Система уравнений
        dSdt = (mu_s * S * (1 - p['m'])      # Рост S (без мутаций)
                - p['delta'] * S * P         # Заражение фагами
                - p['alpha_in'] * S          # Переход в спящее состояние
                + p['alpha_out'] * D)        # Пробуждение

        dRdt = (mu_r * R                     # Рост R
                + mu_s * S * p['m'])         # Мутации S->R

        dIdt = (p['delta'] * S * P           # Заражение
                - p['lambda_lysis'] * I)     # Лизис

        dDdt = (p['alpha_in'] * S            # Переход в спящее состояние
                - p['alpha_out'] * D)        # Пробуждение

        dPdt = (p['beta'] * p['lambda_lysis'] * I  # Высвобождение новых фагов
                - p['delta'] * S * P         # Адсорбция
                - p['d_p'] * P)              # Распад

        dNdt = (-1/p['Y']) * (mu_s * S + mu_r * R)  # Потребление нутриентов

        return [dSdt, dRdt, dIdt, dDdt, dPdt, dNdt]

    def simulate_producer(self, producer_type, t_span=(0, 48), t_eval=None):
        """
        Симуляция для конкретного производителя
        """
        # Начальные условия для разных производителей
        if producer_type == 'producer1':
            # Производитель 1: высокая устойчивость
            # Имеет "подушку безопасности" - спящие клетки и небольшой процент устойчивых
            y0 = [
                1e7,    # S: чувствительные активные
                1e3,    # R: устойчивые активные
                0,      # I: зараженные
                1e6,    # D: спящие (10% от S)
                0,      # P: фаги (добавятся позже)
                self.params['N0']  # N: нутриенты
            ]
            label = "Производитель 1 (устойчивая культура)"
            color = 'blue'

        elif producer_type == 'producer2':
            # Производитель 2: низкая устойчивость
            # "Наивная" культура - только активные чувствительные клетки
            y0 = [
                1e7,    # S: чувствительные активные
                1,      # R: практически нет устойчивых
                0,      # I: зараженные
                1e2,    # D: практически нет спящих
                0,      # P: фаги
                self.params['N0']  # N: нутриенты
            ]
            label = "Производитель 2 (чувствительная культура)"
            color = 'red'

        else:
            raise ValueError("Неизвестный тип производителя")

        if t_eval is None:
            t_eval = np.linspace(t_span[0], t_span[1], 1000)

        # Решение системы ОДУ
        sol = solve_ivp(
            partial(self.equations, params=self.params, phage_addition_time=10, phage_dose=1e6),
            t_span,
            y0,
            t_eval=t_eval,
            method='RK45',
            rtol=1e-6,
            atol=1e-9
        )

        return sol, label, color

    def plot_results(self, sol1, sol2, label1, label2):
        """
        Сравнительное построение результатов для двух производителей
        """
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        t = sol1.t

        # Общие настройки
        titles = [
            'Активные чувствительные бактерии',
            'Активные устойчивые бактерии',
            'Зараженные бактерии',
            'Спящие бактерии',
            'Свободные фаги',
            'Концентрация нутриентов'
        ]

        ylabels = [
            'Концентрация (клеток/мл)',
            'Концентрация (клеток/мл)',
            'Концентрация (клеток/мл)',
            'Концентрация (клеток/мл)',
            'Концентрация (частиц/мл)',
            'Концентрация (г/л)'
        ]

        scales = ['log', 'log', 'log', 'log', 'log', 'linear']

        for i, (ax, title, ylabel, scale) in enumerate(zip(axes.flat, titles, ylabels, scales)):
            # Данные для производителя 1
            y1 = sol1.y[i]
            # Данные для производителя 2
            y2 = sol2.y[i]

            ax.plot(t, y1, 'b-', linewidth=2, label=label1)
            ax.plot(t, y2, 'r--', linewidth=2, label=label2)

            ax.set_title(title)
            ax.set_xlabel('Время (часы)')
            ax.set_ylabel(ylabel)
            ax.set_yscale(scale)
            ax.grid(True, alpha=0.3)
            ax.legend()

            # Отметка времени добавления фагов
            ax.axvline(x=10, color='gray', linestyle=':', alpha=0.7, label='Добавление фагов')

        plt.tight_layout()
        return fig

    def analyze_survival(self, sol):
        """
        Анализ выживаемости культуры
        """
        # Общая биомасса в конце симуляции
        total_biomass_end = sum(sol.y[0:4, -1])  # S + R + I + D

        # Максимальная биомасса
        total_biomass_max = max([sum(sol.y[0:4, i]) for i in range(len(sol.t))])

        # Процент выживания
        survival_ratio = total_biomass_end / total_biomass_max if total_biomass_max > 0 else 0

        return {
            'total_biomass_end': total_biomass_end,
            'total_biomass_max': total_biomass_max,
            'survival_ratio': survival_ratio,
            'survival_status': 'ВЫЖИЛА' if survival_ratio > 0.1 else 'ПОГИБЛА'
        }

def parameter_sensitivity_analysis():
    """
    Анализ чувствительности модели к ключевым параметрам
    """
    model = PhageResistanceModel()

    # Исследуемые параметры
    test_params = {
        'alpha_in': [0.01, 0.05, 0.1],      # Скорость засыпания
        'alpha_out': [0.005, 0.01, 0.02],   # Скорость пробуждения
        'm': [1e-7, 1e-6, 1e-5],           # Частота мутаций
        'D0_fraction': [0.01, 0.1, 0.3]     # Начальная доля спящих
    }

    results = {}

    for param_name, values in test_params.items():
        survival_ratios = []

        for value in values:
            # Модифицируем параметры модели
            temp_model = PhageResistanceModel()

            if param_name == 'D0_fraction':
                # Специальный случай - меняем начальные условия
                pass  # Реализация требует изменения метода simulate_producer
            else:
                temp_model.params[param_name] = value

            # Симуляция для производителя 2 (чувствительная культура)
            sol, _, _ = temp_model.simulate_producer('producer2')
            analysis = temp_model.analyze_survival(sol)
            survival_ratios.append(analysis['survival_ratio'])

        results[param_name] = (values, survival_ratios)

    return results

def main():
    """
    Основная симуляция и анализ
    """
    print("=== Моделирование фаговой устойчивости заквасочных культур ===")

    # Создание и настройка модели
    model = PhageResistanceModel()

    print("\nПараметры модели:")
    for key, value in model.params.items():
        print(f"  {key}: {value}")

    # Симуляция для двух производителей
    print("\nЗапуск симуляции...")
    sol1, label1, color1 = model.simulate_producer('producer1')
    sol2, label2, color2 = model.simulate_producer('producer2')

    # Анализ результатов
    analysis1 = model.analyze_survival(sol1)
    analysis2 = model.analyze_survival(sol2)

    print(f"\nРезультаты анализа:")
    print(f"{label1}: {analysis1['survival_status']} (выживаемость: {analysis1['survival_ratio']:.2%})")
    print(f"{label2}: {analysis2['survival_status']} (выживаемость: {analysis2['survival_ratio']:.2%})")

    # Построение графиков
    print("\nПостроение графиков...")
    fig = model.plot_results(sol1, sol2, label1, label2)

    # Дополнительный анализ: динамика общей биомассы
    fig2, ax = plt.subplots(1, 1, figsize=(10, 6))

    total_biomass1 = [sum(sol1.y[0:4, i]) for i in range(len(sol1.t))]  # S + R + I + D
    total_biomass2 = [sum(sol2.y[0:4, i]) for i in range(len(sol2.t))]

    ax.plot(sol1.t, total_biomass1, 'b-', linewidth=2, label=label1)
    ax.plot(sol2.t, total_biomass2, 'r--', linewidth=2, label=label2)
    ax.axvline(x=10, color='gray', linestyle=':', alpha=0.7, label='Добавление фагов')

    ax.set_title('Динамика общей биомассы бактерий')
    ax.set_xlabel('Время (часы)')
    ax.set_ylabel('Общая биомасса (клеток/мл)')
    ax.set_yscale('log')
    ax.grid(True, alpha=0.3)
    ax.legend()

    plt.tight_layout()

    print("\nСимуляция завершена!")
    return model, sol1, sol2, fig, fig2

if __name__ == "__main__":
    # Запуск основной симуляции
    model, sol1, sol2, fig1, fig2 = main()

    # Демонстрация результатов
    plt.show()

    # Дополнительный анализ: как изменится результат при разных начальных условиях
    print("\n=== Дополнительный анализ: влияние начальной доли спящих клеток ===")

    test_D0_values = [1e2, 1e4, 1e5, 1e6]  # Разные начальные концентрации спящих клеток

    for D0 in test_D0_values:
        # Создаем модифицированные начальные условия для производителя 2
        y0_modified = [
            1e7,    # S
            1,      # R
            0,      # I
            D0,     # D (меняем этот параметр)
            0,      # P
            model.params['N0']  # N
        ]

        # Симуляция с модифицированными условиями
        t_eval = np.linspace(0, 48, 1000)
        sol_mod = solve_ivp(
            partial(model.equations, params=model.params, phage_addition_time=10, phage_dose=1e6),
            (0, 48),
            y0_modified,
            t_eval=t_eval,
            method='RK45'
        )

        analysis = model.analyze_survival(sol_mod)
        print(f"Начальные спящие клетки: {D0:.0e} -> Выживаемость: {analysis['survival_ratio']:.2%} ({analysis['survival_status']})")



